import logging
import json
from typing import Dict, Any, List, Optional

from config.config import Config
from data_managers.market_state import MarketState
from strategy.strategy_router import StrategyRouter
from strategy.trade_module_trapx import TradeModuleTrapX
from strategy.trade_module_scalpel import TradeModuleScalpel
from rolling5_engine import Rolling5Engine
from simulators.entry_range_simulator import EntryRangeSimulator
from ai_client import AIClient
from memory_tracker import MemoryTracker

logger = logging.getLogger(__name__)

class AIStrategy:
    def __init__(self, config: Config, strategy_router: StrategyRouter, forecaster: Rolling5Engine, ai_client: AIClient, entry_simulator: EntryRangeSimulator):
        self.config = config
        self.strategy_router = strategy_router
        self.forecaster = forecaster
        self.ai_client = ai_client
        self.entry_simulator = entry_simulator
        self.memory_tracker = MemoryTracker(config)
        logger.debug("AIStrategy initialized.")

    async def generate_signal(self, market_state: MarketState, validator_audit_log: Dict[str, Any]) -> Dict[str, Any]:
        logger.debug("Generating AI signal with validator audit log: %s", validator_audit_log)
        
        forecast = await self.forecaster.generate_forecast(market_state)
        logger.debug("Rolling5 forecast: %s", forecast)
        
        signal_packet = await self.strategy_router.route_and_generate_signal(market_state, validator_audit_log)
        logger.debug("Signal packet from strategy router: %s", signal_packet)
        
        if signal_packet is None:
            logger.warning("No signal packet generated by StrategyRouter")
            return {
                "direction": "N/A",
                "trade_type": "N/A",
                "ai_verdict": {"action": "⛔ Abort", "confidence": 0.0, "reasoning": "No signal packet from StrategyRouter"},
                "reason": "No signal packet generated",
                "confidence": 0.0
            }
        
        context_packet = {
            "market_state_snapshot": market_state.get_latest_data_snapshot(),
            "validator_audit_log": validator_audit_log,
            "rolling5_forecast": forecast,
            "direction": signal_packet.get("direction", "N/A"),
            "trade_type": signal_packet.get("trade_type", "N/A")
        }
        
        similar_scenarios = self.memory_tracker.get_similar_scenarios(context_packet)
        context_packet["similar_scenarios"] = similar_scenarios
        
        ai_verdict = await self.ai_client.get_ai_verdict(context_packet)
        logger.debug("AI verdict received: %s", ai_verdict)
        
        final_signal = {
            "direction": signal_packet.get("direction", "N/A"),
            "trade_type": signal_packet.get("trade_type", "N/A"),
            "ai_verdict": ai_verdict,
            "reason": ai_verdict.get("reasoning", "No reasoning provided"),
            "confidence": ai_verdict.get("confidence", 0.0)
        }
        
        if ai_verdict.get("action") == "✅ Execute":
            entry_price = market_state.mark_price or 0.0
            is_safe, risk_reason = self.entry_simulator.check_liquidation_risk(
                entry_price=entry_price,
                trade_direction=signal_packet.get("direction", "N/A"),
                forecast_data=forecast
            )
            final_signal.update({"risk_check": {"is_safe": is_safe, "reason": risk_reason}})
            if not is_safe:
                final_signal["ai_verdict"] = {"action": "⛔ Abort", "confidence": 0.0, "reasoning": risk_reason}
        
        await self.memory_tracker.update_memory(filter_report=validator_audit_log, trade_data={
            "direction": final_signal["direction"],
            "ai_verdict": final_signal["ai_verdict"],
            "order_data": final_signal.get("order_data", {})
        })
        logger.debug("Final signal generated: %s", final_signal)
        return final_signal